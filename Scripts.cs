using System;
using System.Collections.Generic;
using System.Dynamic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.ExceptionServices;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Scripting;
using Microsoft.CodeAnalysis.Scripting;
using TaleWorlds.CampaignSystem;
using TaleWorlds.Library;
using StringWriter = System.IO.StringWriter;

namespace Int19h.Bannerlord.CSharp.Scripting {
    public class Scripts : DynamicObject {
        internal static readonly string SharedLocation = Path.Combine(
            Path.GetDirectoryName(typeof(Scripts).Assembly.Location),
            "Scripts"
        );

        internal static readonly string UserLocation = Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.Personal),
            "Mount and Blade II Bannerlord",
            "Scripts"
        );

        internal static readonly string RspFilePath = Path.Combine(
            Path.GetTempPath(),
            "Int19h.Bannerlord.CSharp.Scripting.rsp"
        );

        static Scripts() {
            using (var writer = File.CreateText(RspFilePath)) {
                writer.WriteLine("# DO NOT EDIT THIS FILE!");
                writer.WriteLine("# It is automatically generated by the C# Scripting mod, and will be overwritten.");
                writer.WriteLine();

                //writer.WriteLine($"");

                writer.WriteLine($"/r:\"{typeof(ScriptGlobals).Assembly.Location}\"");
                writer.WriteLine($"/r:\"{typeof(Microsoft.CSharp.RuntimeBinder.RuntimeBinderException).Assembly.Location}\"");
                var nss = new HashSet<string>();
                foreach (var asm in AppDomain.CurrentDomain.GetAssemblies()) {
                    if (asm.IsDynamic || string.IsNullOrEmpty(asm.Location)) {
                        continue;
                    }
                    writer.WriteLine($"/r:\"{asm.Location}\"");
                    foreach (var type in asm.GetExportedTypes()) {
                        var ns = type.Namespace;
                        if (ns != null && (ns.StartsWith("TaleWorlds") || ns.StartsWith("SandBox"))) {
                            nss.Add(ns);
                        }
                    }
                }
                writer.WriteLine();

                writer.WriteLine("/u:System");
                writer.WriteLine("/u:System.Collections.Generic");
                writer.WriteLine("/u:System.Linq");
                writer.WriteLine("/u:System.Reflection");
                writer.WriteLine("/u:System.Text");
                foreach (var ns in nss) {
                    writer.WriteLine($"/u:{ns}");
                }
                writer.WriteLine($"/u:{typeof(ScriptGlobals).FullName}");
                writer.WriteLine();

                foreach (var loadPath in GetSearchPaths()) {
                    writer.WriteLine($"/loadpath:\"{loadPath}\"");
                }
                writer.WriteLine();

                var gameAppVer = ApplicationVersion.FromParametersFile(ApplicationVersionGameType.Singleplayer);
                var gameVer = new Version(gameAppVer.Major, gameAppVer.Minor, gameAppVer.Revision);
                for (var major = 1; major < 10; ++major) {
                    for (var minor = 5; minor < 10; ++minor) {
                        for (var release = 0; release < 20; ++release) {
                            var ver = new Version(major, minor, release);
                            if (ver <= gameVer) {
                                writer.WriteLine($"/d:BANNERLORD_{major}_{minor}_{release}");
                            }
                        }
                    }
                }
            }
        }

        internal static IEnumerable<string> GetSearchPaths() {
            if (Campaign.Current != null) {
                yield return Path.Combine(UserLocation, "Campaigns", Campaign.Current.UniqueGameId);
            }
            yield return UserLocation;
            yield return SharedLocation;
        }

        internal static ScriptOptions GetScriptOptions() {
            var baseDir = Path.GetDirectoryName(RspFilePath);
            var sdkDir = Path.GetDirectoryName(typeof(object).GetType().Assembly.ManifestModule.FullyQualifiedName);
            var rsp = CSharpCommandLineParser.Script.Parse(new[] { $"@{RspFilePath}" }, baseDir, sdkDir);
            var refs = rsp.ResolveMetadataReferences(ScriptMetadataResolver.Default);
            var sourceResolver = ScriptSourceResolver.Default.WithSearchPaths(GetSearchPaths());
            return ScriptOptions.Default
                .WithEmitDebugInformation(true)
                .WithSourceResolver(sourceResolver)
                .AddReferences(refs)
                .AddImports(rsp.CompilationOptions.Usings);
        }

        internal static void IgnoreVisibility(Microsoft.CodeAnalysis.Scripting.Script script) {
            var options = (CSharpCompilationOptions)script.GetCompilation().Options;

            var metadataImportOptionsProperty = typeof(CompilationOptions).GetProperty("MetadataImportOptions", BindingFlags.Instance | BindingFlags.Public);
            metadataImportOptionsProperty.SetValue(options, MetadataImportOptions.All);

            var topLevelBinderFlagsProperty = typeof(CSharpCompilationOptions).GetProperty("TopLevelBinderFlags", BindingFlags.Instance | BindingFlags.NonPublic);
            var flags = (uint)topLevelBinderFlagsProperty.GetValue(options);
            const uint IgnoreAccessibility = 1u << 22;
            flags |= IgnoreAccessibility;
            topLevelBinderFlagsProperty.SetValue(options, flags);
        }

        public override bool TryGetMember(GetMemberBinder binder, out object result) {
            result = new Script(binder.Name);
            return true;
        }
    }

    public class Script : DynamicObject {
        private string Name { get; }

        private string FileName => Name + ".csx";

        public Script(string name) {
            Name = name;
        }

        public override bool TryInvoke(InvokeBinder binder, object?[] args, out object? result) {
            result = Invoke(Name, binder.CallInfo, args);
            return true;
        }

        public override bool TryInvokeMember(InvokeMemberBinder binder, object?[] args, out object? result) {
            result = Invoke(binder.Name, binder.CallInfo, args);
            return true;
        }

        private object? Invoke(string funcName, CallInfo callInfo, object?[] args) {
            var code = new StringWriter();
            code.WriteLine($"#load \"{FileName}\"");

            int posCount = callInfo.ArgumentCount - callInfo.ArgumentNames.Count;
            var argNames = Enumerable.Repeat((string?)null, posCount).Concat(callInfo.ArgumentNames).ToArray();
            code.WriteLine($"#line 1 \"{FileName}\"");
            code.Write($"return (global::System.Action<dynamic[]>)(args => {funcName}(");
            for (int i = 0; i < args.Length; ++i) {
                if (i != 0) {
                    code.Write(", ");
                }

                var argName = argNames[i];
                if (argName != null) {
                    code.Write($"{argName}: ");
                }
                code.Write($"args[{i}]");
            }
            code.WriteLine("));");

            var script = CSharpScript.Create<Action<object?[]>>(code.ToString(), Scripts.GetScriptOptions());
            Scripts.IgnoreVisibility(script);
            var state = script.RunAsync().GetAwaiter().GetResult();
            var invoker = state.ReturnValue;
            var oldScriptPath = ScriptGlobals.ScriptPath;
            ScriptGlobals.ScriptPath = FileName;
            args = args.Select(arg => ScriptArgument.Wrap(arg)).ToArray();
            try {
                invoker(args);
                return null;
            } catch (TargetInvocationException ex) {
                ExceptionDispatchInfo.Capture(ex.InnerException).Throw();
                throw;
            } finally {
                ScriptGlobals.ScriptPath = oldScriptPath;
            }
        }
    }
}
